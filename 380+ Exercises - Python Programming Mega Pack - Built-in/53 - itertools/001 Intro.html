<p>More: <a href="https://docs.python.org/3/library/itertools.html" rel="noopener noreferrer" target="_blank">https://docs.python.org/3/library/itertools.html</a></p><p><strong>Docs:</strong></p><pre class="prettyprint linenums">&gt;&gt;&gt; help(itertools)

Help on built-in module itertools:

NAME
    itertools - Functional tools for creating and using iterators.

DESCRIPTION
    Infinite iterators:
    count(start=0, step=1) --&gt; start, start+step, start+2*step, ...
    cycle(p) --&gt; p0, p1, ... plast, p0, p1, ...
    repeat(elem [,n]) --&gt; elem, elem, elem, ... endlessly or up to n times
    
    Iterators terminating on the shortest input sequence:
    accumulate(p[, func]) --&gt; p0, p0+p1, p0+p1+p2
    chain(p, q, ...) --&gt; p0, p1, ... plast, q0, q1, ...
    chain.from_iterable([p, q, ...]) --&gt; p0, p1, ... plast, q0, q1, ...
    compress(data, selectors) --&gt; (d[0] if s[0]), (d[1] if s[1]), ...
    dropwhile(pred, seq) --&gt; seq[n], seq[n+1], starting when pred fails
    groupby(iterable[, keyfunc]) --&gt; sub-iterators grouped by value of keyfunc(v)
    filterfalse(pred, seq) --&gt; elements of seq where pred(elem) is False
    islice(seq, [start,] stop [, step]) --&gt; elements from
           seq[start:stop:step]
    starmap(fun, seq) --&gt; fun(*seq[0]), fun(*seq[1]), ...
    tee(it, n=2) --&gt; (it1, it2 , ... itn) splits one iterator into n
    takewhile(pred, seq) --&gt; seq[0], seq[1], until pred fails
    zip_longest(p, q, ...) --&gt; (p[0], q[0]), (p[1], q[1]), ...
    
    Combinatoric generators:
    product(p, q, ... [repeat=1]) --&gt; cartesian product
    permutations(p[, r])
    combinations(p, r)
    combinations_with_replacement(p, r)

CLASSES
    builtins.object
        accumulate
        chain
        combinations
        combinations_with_replacement
        compress
        count
        cycle
        dropwhile
        filterfalse
        groupby
        islice
        permutations
        product
        repeat
        starmap
        takewhile
        zip_longest</pre>